<!-- ============================================================ -->
<!-- 【核心修改】板块 2：性能数据录入 (动态 FormSet) -->
<!-- ============================================================ -->
<div class="card mb-3">
    <div class="card-header bg-blue-lt">
        <h3 class="card-title">2. 性能指标数据 (EAV)</h3>
    </div>
    <div class="table-responsive">
        <table class="table table-vcenter card-table" id="data-table">
            <thead>
            <tr>
                <th class="w-40 required">测试项目 (指标 | 标准 | 条件)</th>
                <th class="w-25">数值 / 结果</th>
                <th class="w-25">备注</th>
                <th class="w-1">删</th>
            </tr>
            </thead>
            <tbody>
            <!-- 管理表单，必须有！ -->
            {{ data_formset.management_form }}

            {% for subform in data_formset %}
                <tr class="form-row {% if subform.errors %}table-danger{% endif %}">
                    <!-- 隐藏字段 (如 ID) -->
                    {% for hidden in subform.hidden_fields %}
                        {{ hidden }}
                    {% endfor %}

                    <td>
                        {{ subform.test_config }}
                        {% if subform.test_config.errors %}
                            <div class="text-danger small">{{ subform.test_config.errors.0 }}</div>{% endif %}
                    </td>
                    <td>
                        <!-- 数值输入框 -->
                        {{ subform.value }}
                        <!-- 文本输入框 -->
                        {{ subform.value_text }}
                        <!-- 选择框 -->
                        {{ subform.value_select }}
                        
                        {% if subform.value.errors %}
                            <div class="text-danger small">{{ subform.value.errors.0 }}</div>{% endif %}
                    </td>
                    <td>{{ subform.remark }}</td>
                    <td>
                        {% if subform.instance.pk %}
                            <div class="form-check m-0 d-flex justify-content-center">
                                {{ subform.DELETE }}
                                <label class="form-check-label visually-hidden" for="{{ subform.DELETE.id_for_label }}">删除</label>
                            </div>
                        {% endif %}
                    </td>
                </tr>
            {% endfor %}
            </tbody>
        </table>
    </div>
    <div class="card-footer">
        <button type="button" class="btn btn-sm btn-primary" id="add-row">
            <i class="ti ti-plus"></i> 添加一行数据
        </button>
        <span class="text-muted small ms-3">
                    <i class="ti ti-info-circle me-1"></i> 每行代表一个测试项目的数值。
                </span>
    </div>
</div>

<script>
    // 预加载所有 TestConfig 的数据类型信息
    // 格式: { id: {type: 'NUMBER', options: ['A', 'B']} }
    const testConfigMeta = {};
    {% for config in data_formset.form.fields.test_config.queryset %}
        testConfigMeta['{{ config.id }}'] = {
            type: '{{ config.data_type }}',
            options: {{ config.get_options_list|safe }}
        };
    {% endfor %}

    function toggleValueInput(selectElement) {
        const row = selectElement.closest('tr');
        const valueInput = row.querySelector('.value-number');
        const textInput = row.querySelector('.value-text');
        const selectInput = row.querySelector('.value-select');
        const configId = selectElement.value;
        
        if (!configId) return;
        
        const meta = testConfigMeta[configId] || {type: 'NUMBER', options: []};
        
        // 重置显示
        valueInput.style.display = 'none';
        textInput.style.display = 'none';
        selectInput.style.display = 'none';
        
        if (meta.type === 'NUMBER') {
            valueInput.style.display = 'block';
            // 只有当切换到 NUMBER 时才清空其他值，避免误操作
            // 但如果是初始化加载，不应该清空
            if (selectElement.dataset.initialized === 'true') {
                 textInput.value = '';
                 selectInput.value = '';
            }
        } else if (meta.type === 'TEXT') {
            textInput.style.display = 'block';
            if (selectElement.dataset.initialized === 'true') {
                valueInput.value = '';
                selectInput.value = '';
            }
        } else if (meta.type === 'SELECT') {
            selectInput.style.display = 'block';
            if (selectElement.dataset.initialized === 'true') {
                valueInput.value = '';
                textInput.value = '';
            }
            
            // 动态填充选项 (仅当选项为空或需要更新时)
            // 注意：如果是编辑模式，后端可能已经填充了选项，这里需要小心不要覆盖已选值
            // 检查是否已经有选项了 (除了默认的空选项)
            if (selectInput.options.length <= 1) {
                // 保存当前值 (如果是编辑回显)
                const currentValue = selectInput.getAttribute('data-current-value') || selectInput.value;
                
                // 清空现有选项
                selectInput.innerHTML = '';
                // 添加空选项
                const emptyOpt = document.createElement('option');
                emptyOpt.value = '';
                emptyOpt.text = '---------';
                selectInput.appendChild(emptyOpt);
                
                // 添加配置的选项
                meta.options.forEach(opt => {
                    const option = document.createElement('option');
                    option.value = opt;
                    option.text = opt;
                    if (opt === currentValue) {
                        option.selected = true;
                    }
                    selectInput.appendChild(option);
                });
            }
        }
        
        // 标记为已初始化
        selectElement.dataset.initialized = 'true';
    }
    
    // 页面加载完成后，初始化所有行的显示状态
    document.addEventListener("DOMContentLoaded", function() {
        // 延迟一点执行，确保 Tom Select 初始化完成 (虽然这里我们操作的是原始 select)
        setTimeout(() => {
            document.querySelectorAll('.form-select-search').forEach(select => {
                // 如果有值，触发一次 toggle
                if (select.value) {
                    // 对于 SELECT 类型，我们需要先从 value_text 中恢复值到 value_select
                    // 因为 value_select 是动态生成的，后端渲染时可能没有正确回显
                    // 或者我们在 form __init__ 中已经处理了，这里只需要确保选项存在
                    
                    // 找到对应的行
                    const row = select.closest('tr');
                    const selectInput = row.querySelector('.value-select');
                    const textInput = row.querySelector('.value-text');
                    
                    // 如果是 SELECT 类型，且 value_select 为空但 value_text 有值 (通常是编辑时)
                    // 我们需要把 value_text 的值暂存，以便 toggleValueInput 使用
                    const configId = select.value;
                    const meta = testConfigMeta[configId];
                    
                    if (meta && meta.type === 'SELECT') {
                        // 尝试从 textInput 获取值 (因为数据库存的是 value_text)
                        // 注意：在 form __init__ 中我们可能已经把值赋给了 initial，但前端渲染时 options 是空的
                        // 所以 value 属性可能没生效。我们需要手动处理。
                        // 这里假设 value_text 字段里有值 (虽然它被隐藏了)
                        // 或者我们可以从 value_select 的 value 属性尝试获取 (如果 form 渲染了 value)
                        
                        // 更可靠的方法：在后端 form 渲染时，把值放到 data-current-value 属性上
                        // 但这里我们只能操作 DOM。
                        
                        // 变通：检查 textInput 的 value
                        if (textInput.value) {
                            selectInput.setAttribute('data-current-value', textInput.value);
                        }
                    }
                    
                    toggleValueInput(select);
                }
            });
        }, 100);
    });
</script>